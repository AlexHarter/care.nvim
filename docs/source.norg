@document.meta
title: Source
description: Type description of neocomplete.nvim source
authors: [
    max397574
]
categories: [
    docs,
    types
]
created: 2023-11-15T17:42:46+0100
updated: 2024-06-09T11:50:40+0100
tangle: {
    languages: {
        lua: ../lua/neocomplete/types/source.lua
    }
    scope: tagged
    delimiter: none
}
version: 1.1.1
@end

* General
  The sources are used to get get completions for neocomplete.nvim.

  #tangle
  @code lua
  --- A completion source for neocomplete.nvim
  ---@class neocomplete.source
  @end

* Methods
** `is_available()`
   Each source can have a function to show whether it's available or not. If your source should
   for example be enabled for a certain filetype you can just do it like this:
   @code lua
   function my_source.is_available()
       return vim.bo.ft == "lua"
   end
   @end

   This function will be called quite often so developers should try to keep it more or less
   performant. This won't be an issue in the vast majority of cases though.

   #tangle
   @code lua
   --- Whether the source will provide completions in the current context or not
   ---@field is_available? fun(): boolean
   @end

** `get_trigger_characters()`
   This function should return characters which trigger completion for the source. If one of those
   characters is types the completion will be retriggered. Otherwise newly entered characters are
   used for sorting and filtering.
   An example for this could be `.`, `\\` and `/` when working with paths.
   @code lua
   function my_source.get_trigger_characters()
       return { ".", "\\", "/" }
   end
   @end

   #tangle
   @code lua
   --- Characters which should trigger new completions of the source
   ---@field get_trigger_characters? fun(): string[]
   @end

** Keyword pattern
   The keyword pattern is used to overwrite the keyword pattern from the config per source. It
   should basically represent the format of entries the source will provide as regex.
   It can either be provided as a string with `keyword_pattern` or dynamically with
   `get_keyword_pattern`.
   The `get_keyword_pattern` function has higher priority and will overwrite the string if provided.
   #tangle
   @code lua
   --- Keyword pattern for this source
   ---@field keyword_pattern? string
   @end

   #tangle
   @code lua
   --- Get keyword pattern for this source
   ---@field get_keyword_pattern? fun(self: neocomplete.source): string
   @end


** Complete
   This is arguably the most important function of each source. This function returns completions.
   The function takes in a {:./index:* Completion Context}[completion context] and should return a
   list of {:./entry:}[entries].

   #tangle
   @code lua
   --- Returns completion in the provided context
   ---@field complete fun(completion_context: neocomplete.completion_context, callback: fun(items: neocomplete.entry[], is_incomplete?: boolean)): nil
   @end
